.text
	代码段
	
.data
	数据段，常量、字符串字面量、全局变量
	name: storage_type value,...
	
	
#注释

$0-$31 表示寄存器
$0 恒为0
$at $k0 $k1 不能修改
$v0 $v1 存放函数返回值
$a0-$a3 存放函数参数
$t0-$t9 调用者保存寄存器         随便用
$s0-$s7 被调用者保存寄存器       随便用
$ra  函数返回地址
$sp 栈的顶部

系统调用：
print_string(_prompt) 等价代码如下：
	li $v0, 4              #4表示调用类型  (print_string)
	la $a0, _prompt        #存参数
	syscall
	
	
	
指令选择、寄存器分配、栈管理	
	
	
1.无视与函数调用有关的 CALL、 ARG、 PARAM、 RETURN等语句，专心处理其他类型的中间代码。你可以先假设寄存器有无限多个（编号$t0, $t1, …, $t99, $t100, …）， 试着完
成指令选择，然后将经过指令选择之后的代码打印出来看一下是否正确。
2.完成寄存器分配算法，这时你就会开始考虑如何向栈里溢出变量的问题了。当寄存器分配也完成之后，你可以试着自己写几个不带函数调用的 C--测试程序，将编译器输出的目标代码送入 SPIM 中运行查看结果是否正确。
3.设计一个活动记录的布局方式，然后完成对 ARG、 PARAM、RETURN 和 CALL 的翻译。对这些代码的翻译实际上就是一个输出过程调用序列的过程，调用者和被调用者的调用序列要互相配合着来做，这样不容易出现问题。处理 ARG 和 PARAM 时要注意实参和形参的顺序不要搞错，另外计算实参时如果你没有使用$fp 那么也要注意各临时变量相对于$sp 偏移量的修改。如果调用序列出现问题，请善于利用SPIM 的单步执行功能对你的编译器的输出代码进行调试。
